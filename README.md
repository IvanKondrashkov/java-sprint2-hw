# task-tracker
## Типы задач
Простейшим кирпичиком такой системы является задача (англ. task). У задачи есть следующие свойства:

1. Название, кратко описывающее суть задачи (например, «Переезд»).
2. Описание, в котором раскрываются детали.
3. Уникальный идентификационный номер задачи, по которому её можно будет найти.
4. Статус, отображающий её прогресс. Мы будем выделять следующие этапы жизни задачи:
   * `NEW` — задача только создана, но к её выполнению ещё не приступили.
   * `IN_PROGRESS` — над задачей ведётся работа.
   * `DONE` — задача выполнена.
    
Иногда для выполнения какой-нибудь масштабной задачи её лучше разбить на подзадачи (англ. subtask). Большую задачу, которая делится на подзадачи, мы будем называть эпиком (англ. epic).
Таким образом, в нашей системе задачи могут быть трёх типов: обычные задачи, эпики и подзадачи. Для них должны выполняться следующие условия:
  * Для каждой подзадачи известно, в рамках какого эпика она выполняется.
  * Каждый эпик знает, какие подзадачи в него входят.
  * Завершение всех подзадач эпика считается завершением эпика.

## Менеджер
Кроме классов для описания задач, вам нужно реализовать класс для объекта-менеджера. Он будет запускаться на старте программы и управлять всеми задачами. В нём должны быть реализованы следующие функции:

1. Возможность хранить задачи всех типов. Для этого вам нужно выбрать подходящую коллекцию.
2. Методы для каждого из типа задач(Задача/Эпик/Подзадача):
   * Получение списка всех задач.
   * Удаление всех задач.
   * Получение по идентификатору.
   * Создание. Сам объект должен передаваться в качестве параметра.
   * Обновление. Новая версия объекта с верным идентификатором передаются в виде параметра.
   * Удаление по идентификатору.
3. Дополнительные методы:
   * Получение списка всех подзадач определённого эпика.
4. Управление статусами осуществляется по следующему правилу:
   * Менеджер сам не выбирает статус для задачи. Информация о нём приходит менеджеру вместе с информацией о самой задаче.
   По этим данным в одних случаях он будет сохранять статус, в других будет рассчитывать.
   * Для эпиков: 
     * если у эпика нет подзадач или все они имеют статус `NEW`, то статус должен быть `NEW`.
     * если все подзадачи имеют статус `DONE`, то и эпик считается завершённым — со статусом `DONE`.
     * во всех остальных случаях статус должен быть `IN_PROGRESS`.

## Менеджер теперь интерфейс
   * Класс `TaskManager`
   должен стать интерфейсом. В нём нужно собрать список методов, которые должны быть у любого объекта-менеджера. Вспомогательные методы, если вы их создавали, переносить в интерфейс не нужно.
   * Созданный ранее класс менеджера нужно переименовать в `InMemoryTaskManager`
   . Именно то, что менеджер хранит всю информацию в оперативной памяти, и есть его главное свойство, позволяющее эффективно управлять задачами. Внутри класса должна остаться реализация методов. При этом важно не забыть имплементировать `TaskManager` — в Java класс должен явно заявить, что он подходит под требования интерфейса.

## История просмотров задач
Добавьте в программу новую функциональность — нужно, чтобы трекер отображал последние просмотренные пользователем задачи. Для этого реализуйте метод `getHistory()` — он должен возвращать последние 10 просмотренных задач. Просмотром будем считаться вызов у менеджера методов получения задачи по идентификатору — `getTask()`, `getSubtask()` и `getEpic()`. От повторных просмотров избавляться не нужно.

## Дальнейшая разработка алгоритма с CustomLinkedList и HashMap
Программа должна запоминать порядок вызовов метода `add`, ведь именно в этом порядке просмотры будут выстраиваться в истории. Для хранения порядка вызовов удобно использовать список.
Если какая-либо задача просматривалась несколько раз, в истории должен отобразиться только последний просмотр. Предыдущий просмотр должен быть удалён сразу же после появления нового — за O(1). Из темы о списках вы узнали, что константное время выполнения операции может гарантировать связный список `CustomLinkedList`. Однако его стандартная реализация в данном случае не подойдёт. Поэтому вам предстоит написать собственную.

## Про CustomLinkedList
Сначала напишите свою реализацию двусвязного списка задач с методами `linkLast` и `getTasks`. `linkLast` будет добавлять задачу в конец этого списка, а `getTasks` собирать все задачи из него в обычный ArrayList. Убедитесь, что решение работает. Отдельный класс для списка создавать не нужно — реализуйте его прямо в классе `InMemoryHistoryManager`. А вот отдельный класс Node для узла списка необходимо добавить.

## Про метод removeNode
Добавьте метод `removeNode` в класс. В качестве параметра этот метод должен принимать объект `Node` — узел связного списка и вырезать его.

## Про HashMap
Создайте HashMap — будет достаточно её стандартной реализации. В ключах будут храниться id задач, а в значениях — узлы связного списка. Изначально HashMap пустая. Она будет заполняться по мере добавления новых задач. Напишите реализацию метода `add(Task task)`. Теперь с помощью HashMap и метода удаления removeNode метод `add(Task task)` будет быстро удалять задачу из списка, если она там есть, а затем вставлять её в конец двусвязного списка. После добавления задачи не забудьте обновить значение узла в HashMap.

## Вторая реализация менеджера
Итак, создайте класс `FileBackedTasksManager`. В нём вы будете прописывать логику автосохранения в файл. Этот класс, как и `InMemoryTasksManager`, должен имплементировать интерфейс менеджера `TasksManager`.

## Метод автосохранения
Пусть новый менеджер получает файл для автосохранения в своём конструкторе и сохраняет его в поле. Создайте метод save без параметров — он будет сохранять текущее состояние менеджера в указанный файл.

Затем нужно продумать логику метода save. Он должен сохранять, все задачи, подзадачи, эпики и историю просмотра любых задач. Для удобства работы рекомендуем выбрать текстовый формат CSV (англ. Comma-Separated Values, «значения, разделённые запятыми»).
```id,type,name,status,description,epic
   1,TASK,Task1,NEW,Description task1,
   2,EPIC,Epic2,DONE,Description epic2,
   3,SUBTASK,Sub Task2,DONE,Description sub task3,2
   
   2,3
```
## Как сохранять задачи в файл и считывать их из него
   * Создайте enum с типами задач.
   * Напишите метод сохранения задачи в строку `String toString(Task task)` или переопределите базовый.
   * Напишите метод создания задачи из строки `Task fromString(String value)`.
   * Напишите статические методы `static String toString(HistoryManager manager)` и `static List<Integer> fromString(String value)` для сохранения и восстановления менеджера истории из CSV.

## Покройте код тестами
Ваша цель — написать отдельный тест для каждого публичного метода: стандартный кейс его работы и граничные случаи.
Потребуются следующие тесты:
   * Для расчёта статуса `Epic`. Граничные условия.
   * Для двух менеджеров задач `InMemoryTasksManager` и `FileBackedTasksManager`.
   * Для `HistoryManager` — тесты для всех методов интерфейса. Граничные условия.
   * Дополнительно для `FileBackedTasksManager`.
   — проверка работы по сохранению и восстановлению состояния. Граничные условия.

## Добавьте продолжительность и дату старта
Добавьте новые поля в задачи:
   * `duration` — продолжительность задачи, оценка того, сколько времени она займёт в минутах (число).
   * `startTime` — дата, когда предполагается приступить к выполнению задачи.
   * `getEndTime()` — время завершения задачи, которое рассчитывается исходя из `startTime` и `duration`.

Менять сигнатуры методов интерфейса `TaskManager` не понадобится: при создании или обновлении задач все его методы будут принимать и возвращать объект, в который вы добавите два новых поля.
С классом `Epic` придётся поработать дополнительно. Продолжительность эпика — сумма продолжительности всех его подзадач. Время начала — дата старта самой ранней подзадачи, а время завершения — время окончания самой поздней из задач. Новые поля `duration` и `startTime` этого класса будут расчётные — аналогично полю статус. Для реализации `getEndTime()` удобно добавить поле `endTime` в `Epic` и рассчитать его вместе с другими полями.

## Выведите список задач в порядке приоритета
Отсортируйте все задачи по приоритету — то есть по `startTime`. Если дата старта не задана, добавьте задачу в конец списка задач, подзадач, отсортированных по `startTime`. Напишите новый метод `getPrioritizedTasks`, возвращающий список задач и подзадач в заданном порядке.
Предполагается, что пользователь будет часто запрашивать этот список задач и подзадач, поэтому подберите подходящую структуру данных для хранения. Сложность получения должна быть уменьшена с O(n log n) до O(n).

## Прорабатываем логику API
Вам нужно реализовать API, где эндпоинты будут соответствовать вызовам базовых методов интерфейса `TaskManager`. Соответствие эндпоинтов и методов называется маппингом.

Сначала добавьте в проект библиотеку `Gson` для работы с JSON. Далее создайте класс `HttpTaskServer`, который будет слушать порт 8080 и принимать запросы. Добавьте в него реализацию `FileBackedTaskManager`, которую можно получить из утилитного класса `Managers`. После этого можно реализовать маппинг запросов на методы интерфейса `TaskManager`.
API должен работать так, чтобы все запросы по пути `/tasks/<ресурсы>` приходили в интерфейс `TaskManager`. Путь для обычных задач — `/tasks/task`, для подзадач — `/tasks/subtask`, для эпиков — `/tasks/epic`. Получить все задачи сразу можно будет по пути `/tasks/`, а получить историю задач по пути `/tasks/history`.
Для получения данных должны быть GET-запросы. Для создания и изменения — POST-запросы. Для удаления — DELETE-запросы. Задачи передаются в теле запроса в формате JSON. Идентификатор (id) задачи следует передавать параметром запроса (через вопросительный знак).
В результате для каждого метода интерфейса `TaskManager` должен быть создан отдельный эндпоинт, который можно будет вызвать по HTTP.

## Доделываем HTTP-сервер для хранения задач
Сейчас задачи хранятся в файлах. Нужно перенести их на сервер. Для этого напишите HTTP-клиент. С его помощью мы переместим хранение состояния менеджера из файлов на отдельный сервер.
`KVServer` — это хранилище, где данные хранятся по принципу <ключ-значение>. Он умеет:
   * GET `/register` — регистрировать клиента и выдавать уникальный токен доступа (аутентификации). Это нужно, чтобы хранилище могло работать сразу с несколькими клиентами.
   * POST `/save/<ключ>?API_TOKEN=` — сохранять содержимое тела запроса, привязанное к ключу.
   * GET `/load/<ключ>?API_TOKEN=` — возвращать сохранённые значение по ключу.

## Пишем HTTP-клиент
Для работы с хранилищем вам потребуется HTTP-клиент, который будет делегировать вызовы методов в HTTP-запросы. Создайте класс `KVTaskClient`. Его будет использовать класс `HTTPTaskManager`, который мы скоро напишем.
При создании KVTaskClient учтите следующее:
   * Конструктор принимает URL к серверу хранилища и регистрируется. При регистрации выдаётся токен (API_TOKEN), который нужен при работе с сервером;
   * Метод `void put(String key, String json)` должен сохранять состояние менеджера задач через запрос POST `/save/<ключ>?API_TOKEN=`;
   * Метод `String load(String key)` должен возвращать состояние менеджера задач через запрос GET `/load/<ключ>?API_TOKEN=`;
